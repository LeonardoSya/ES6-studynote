// Generator是实现状态机的最佳结构
function* clock() {
    while (true) {
        console.log('Tick!');
        yield;
        console.log('Tock!');
        yield;
    }
};
var myClock = clock();
myClock.next()  // Tick!
myClock.next()  // Tock!

// 协程 coroutine
// 协程是一种程序运行的方式(协作的线程/协作的函数)，协程可以用单线程(一种特殊的子例程)或多线程(特殊的线程)实现

// (1)协程与子例程的差异：
/*
    传统的子例程采用堆栈后进先出的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。
    协程与子例程不同，多个线程(多个函数)可以并行执行，但是只有一个线程(函数)处于正在运行的状态，其他线程(函数)都处于暂停态，线程之间可以交换执行权。这种【可以并行执行、交换执行权的线程】，称为协程。
    从实现上看，在内存中，子线程只使用一个栈(stack)，而协程是同时存在多个栈，但只有一个栈在运行状态。也就是说，协程是以多占用内存为代价，实现多任务的并行
*/
// (2)协程与普通线程的差异：
/*
    协程适合用于多任务运行的环境，它也有自己的执行上下文、可以分析全局变量。
    协程与普通线程不同之处在于，同一时间可以有多个线程处于运行状态，但运行的协程只能有一个，其他协程都处于暂停状态
    另外，普通线程是抢先式的，哪个线程优先得到资源必须由运行环境决定，但协程是合作式的，执行权由协程自己分配

    由于js是单线程语言，只能保持一个调用栈，引入协程之后，每个任务可以保持自己的调用栈。这样抛出错误时可以找到原始的调用栈，不至于像异步操作的回调函数那样一旦出错原始的调用栈早就结束
    如果将Generator函数当作协程，完全可以【将多个需要互相协作的任务写成Generator函数】，它们之间用yield表达式交换控制权
*/


//  上下文
// js运行时，会产生一个全局的上下文(context,又称运行环境)，包含了当前所有的变量和对象。执行函数时又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前的上下文，由此形成一个上下文环境的堆栈(context stack)
// 而Generator函数不是这样，它执行产生的上下文环境，一旦遇到yield，就会暂时退出堆栈，内部的所有变量和对象会冻结在当前状态，等到next，上下文环境又会重新加入调用栈，冻结的变量和对象回复执行


